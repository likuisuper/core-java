# 面向对象

OO(Oriented Object),OOP(Oriented Object Programming),OOAD(面向对象分析和设计)

面向对象不是一门具体的技术,它是一个用于编程的思想.

* 面向过程(C) - 优先考虑的是**程序=算法+数据结构**("如何去实现")

  * 比如:买鱼 - 切鱼 - 烧鱼 - 最后才能吃.过程需要考虑,也需要具体

    去实现.

  * C语言特点:一次编写,到处运行[不能跨平台]

* 面向对象(Java,python) - "一切皆对象",**程序=对象.**

  * 比如:菜谱上的每道菜 - "对象" - 点菜即可.
  * Java语言特点 -  一次编译到处运行.



## 思想的核心

符合人类思维方式的思想.遇到一个业务,找出业务中关键的"对象".分析对象的"属性"

[对象拥有什么],接着分析对象的行为[对象的方法,对象能干什么],最后还要考虑对象与

对象之间的联系.



## 对象之间的关系

* 1:1

* 1:N - 70%

* N:N - 一个用户拥有多个角色,一个角色可以拥有多个用户

* ***自关联[暂了解]***

  ~~~java
  员工表
  id name 		manager_id
  1  success
  2  tom        1
  3  james      1
  4  jack       3
  ~~~

  

## 面向对象特点

* ***封装(Encapsulation)*** - 为了屏蔽更多的实现细节.为了数据的安全性.提供一个公开的方式,让

  外界来调用,主要是为了提高程序的**复用性.**和安全性.

* 继承

* 多态



# success感悟

~~~java
//编程的核心就是为了数据的增删改查以及数据分析.

//围绕"数据" - 数据肯定要进行存储.

//变量 - 数据存储在内存中的"容器"
//1. 存储在单个变量中.  int age = 18;

//2. 数据量比较大 - 诞生了"数组"的概念.
// 一个数组保存的是同一类型的多个数据.


//3. 随着业务的复杂 , 数据越来越多,数据类型也是越来越多
//希望找一个容器,可以存放不同类型的多条数据!

//OO - "对象" - 想象成内存中存放数据的"容器".
//Student s = new Student(1,"tom",23,1.75);

//4. 内存中的数据最终都要被持久化[写入]到磁盘中 - DB[数据库]
~~~





# 类和对象

类是抽象的概念,**类是构建对象的蓝图或者模板.**
对象是具体的概念,对象是**类的实例化**.



# 类的介绍

* **属性(member variable 成员变量)**
* 构造(constructor)
* setter/getter 方法
* toString方法



# 属性

属性 - 对象拥有什么?

定义属性的语法:

~~~java
修饰符 数据类型 属性名 [= 初始值];

如果定义属性的时候没有进行初始化,那么系统会默认分配默认值
整数型 - 0,小数型 - 0.0,boolean = false,char->空格
对象类型 -> null
~~~



## 修饰符

### 访问修饰符

* public - 公开的,任何地方都允许被使用
* ***protected*** - 受保护的
* 缺省的 - 在本包中,可以被允许使用.
* private 私有的,只能在本类中被使用.



### 其他修饰符

* static - 静态的,修饰的方法 - 静态方法,修饰的变量 - **静态变量[类变量]**

  没有使用static修饰的变量 - 非静态变量**[实例(对象)变量]**

* final - 最终的,不可变的.final修饰的属性 - 常量属性.
* abstract - 抽象的,修饰类 - 抽象类[不能够被实例化的.]



## 数据类型

* 八大种基本数据类型
* 对象类型[内置的和自定义的]



## 属性名

属性名命名参考变量命名.



# 封装性

如何对属性进行封装

* 属性私有化
* getter/setter方法 - 提供一个公开的方法,来让外界间接操作对象的属性.
  * 思考为什么要进行属性的封装?
    * 可以在setter方法内部进行参数有效性判断.
    
    * 如果业务中涉及到了属性名的修改的话 - 有利于代码的可维护性.
    
    * 可以屏蔽更多的操作细节 - 为了数据的安全性.
    
    * 有的属性是不希望暴露在外部的.
    
    * 有的**属性数据是一个整体**,比如[购物车对象Cart,单价,数量,总价].
    
      总价 = 单价*数量
    
      ~~~java
      Cart c = new Cart();
      c.price = 100;
      c.num = 20;
      //一旦修改了单价,还必须要手动去修改总价
      c.total = c.price * c.num;
      
      public void setPrice(double price){
        this.price = price;
      }
      
      public void setNum(int num){
        this.num = num;
      }
      
      public double getTotal(){
        return price*num;
      }
      
      c.setPrice(100);
      c.setNum(10);
      System.out.println(c.getTotal);
      ~~~
    
      

# this关键字

* **this代表的是当前对象**,调用方法的对象.
* 当方法的参数列表中的参数名和类中的属性名同名的时候,需要使用this.属性名来强制告诉程序使用的是类中的属性.
* 和**构造方法**相关的作用
  * 在构造体中使用this()来调用当前实体类中存在的空参构造
  * 在构造体中使用this(参数列表)来调用当前实体类中存在的带参构造
  * 注意点:构造体中的this([参数列表])调用构造方法的语法必须在首行.



# 构造方法

简介:**构造方法是允许重载的**,但是是不允许重写的.

~~~java
修饰符 构造方法名([参数列表]){
  //构造体.
}
//1. 不需要手动指定构造方法的返回类型
//2. 构造方法的名称和类的简称高度保持一致
//3. 如果没有参数 - 空参构造,如果带有参数 - 带参构造.如果参数的个数和属性的个数一致 - 全参构造.
//4. 如果一个实体类中,没有手动指定任何一个构造的时候,那么系统会默认分配一个空参构造
     //但是一旦实体类中手动提供了任何一个带参构造的时候,那么系统将不会默认再分配这个空参构造了.
~~~



## 作用

* 空参构造 - 创建一个对象,所有的属性都是系统分配的默认值.

* 带参构造

  * 可以在创建对象的同时,对对象中的属性进行赋值.

  * 但是和setter方法赋值方式进行比较的话,区别是:

    * setter方法可以使用同一个对象进行多次赋值.

    * 带参构造的赋值方式只有一次.

    * 如果带参构造进行属性赋值的时候,需要进行参数有效性判断的话

      那么推荐在带参构造中去调用setter方法.



# toString方法

java.lang.Object中提供的toString方法的底层源码:

~~~java
public String toString() {
  return this.getClass().getName() + "@" + Integer.toHexString(this.hashCode());
}
~~~



~~~java
package tech.aistar.day07;

import java.util.Date;

/**
 * 本类用来演示:
 *
 * @author: success
 * @date: 2020/7/27 2:58 下午
 */
public class ToStringDemo {
    public static void main(String[] args) {
        User user = new User(1,"admin","123",new Date());

        //没有重写toString方法之前,打印对象,出来的是内存地址

        //打印对象的时候,实际上在调用该对象的toString方法
        System.out.println(user);//tech.aistar.day07.User@330bedb4

        //User实体中并没有提供String toString();

        //当一个实体类没有手动指定它的父类的时候,那么这个类将会直接继承java.lang.Object
        //java.lang.Object这个类是所有对象的超类,父类,根类,基类.

        //默认提供的toString输出,并不满足我们实际的打印需求
        //实际的打印需求 - 返回对象中的属性的字符串表现形式
        System.out.println(user.toString());

        //需要在User类中自己手动提供toString方法来满足实际的打印需求.

//        Date date = new Date();
//        System.out.println(date.toString());
//
//        String str = "abc";
//        System.out.println(str.toString());

    }
}
~~~



# 练习

元素类型[] 变量名 = new 元素类型[数组长度];

* 创建一个User型数组,长度是3个.里面放3个user
* 遍历数组输出.







































