# OO的高级特性

* 抽象类
* 接口



# 抽象类

简介:使用abstract关键字来定义的类 - 抽象类.



* 抽象类是不能够被实例化的.
* 抽象类中可以提供普通属性以及普通方法
* 抽象类中一定存在构造,并且绝对不推荐私有.
* 抽象类天生就是用来被继承的.
* 只有接口和抽象类才有资格去定义**抽象方法**
  * 抽象方法 - 使用abstract修饰的方法,特点:是没有方法体的方法.
  * 抽象方法天生就是用来被子类重写的.

* 抽象类也仅仅支持单继承.
* 抽象类中也是可以定义静态方法的.



# 继承性

* 当一个普通的类去继承一个抽象的父类的时候,那么在编译期间,要求普通子类强制去重写父类中的所有的抽象方法.非抽象方法,子类可以选择性重写或者不重写.
* 当一个抽象的子类去继承一个抽象的父类的时候,那么在编译期间,抽象的子类可以选择性去重写父类中的所有的方法[包括抽象和非抽象].



# 互斥的修饰符

* final和abstract不能同时修饰类.

  final修饰的类是不允许被继承的,但是abstract修饰的抽象类天生就是用来被继承的.

* static和abstract能否同时修饰方法

  static修饰的方法是不能够被重写,static修饰的方法是没有多态的.

  abstract天生就是为了被重写,天生就是为了多态.

* private和abstract能否同时修饰方法

  private私有方法是不能被子类重写的.

* final和abstract是否能够同时修饰方法

  final修饰的方法不能被重写.



# 应用场景

抽象类负责定义业务的结构,让业务的具体的细节延迟到子类中去实现.



## 模板设计模式

## 模板方法优缺点

模板方法的优点和缺点：

**优点**：

1. 模板方法提供了一个很好的代码复用平台。
2. 实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，符合 "开闭原则"。

**缺点：**

每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 - 推荐使用匿名内部类语法.



# 接口

简介:指定业务方法的[不要具体实现],***屏蔽底层代码,是一种"契约".***替代之前的业务类.

使用interface关键字来进行修饰的.但是经过编译之后,仍然是一个.class文件.



关于接口的命名:

* 推荐使用I开头
* 或者推荐使用able结尾.



## 特点

* 接口中是可以定义普通方法的,是JDK8.0之后,并且还需要使用关键字default.

* 接口中是可以定义抽象方法的.

* 接口中只能定义公开的静态的常量属性 - 在JDK5.0以后已经不推荐在接口中

  定义常量属性了,而是推荐在枚举类型中定义这些公开的静态的常量属性.

* 接口中是不允许手动提供构造方法的.
* 接口也是不能够被实例化的.



## 实现类

接口定义好功能,需要实现类去实现这个接口中的功能

* 当一个普通类实现某个接口的时候,那么这个普通类必须要实现这个接口以及这个接口的父接口中的所有的 抽象的方法.

  

* 如果这个类是一个抽象类,那么就不需要强制实现这个IC接口中的所有的抽象方法了.



## 关系

* 类与类之间的关系 - ***继承***.extends

* 接口与接口关系 - ***继承***,一个接口可以支持继承多个接口/

  接口是支持多重继承的.

* 类与接口 - 一个类可以***实现***多个接口.当然一个接口也可以拥有多个实现类.

  所以类和接口这种实现的关系N:N

  implements



## 面向接口编程

多态的应用有两方面

* 面向父类编程
* 面向接口编程
  * 对象的编译时类型写成接口,对象的运行时类型写成接口的实现类
  * 方法的参数类型写成接口,调用方法传递的参数可以是这个接口的任何一个实现类对象.
  * 方法的返回类型是接口,方法体中的返回值可以是这个接口的任何一个实现类对象.



## 接口的分类

* 业务接口 - 只提供业务方法[抽象方法]的接口.

* 常量接口 - 只提供公开的静态的常量属性的接口 - 统一管理系统中的常量属性.

* 函数式接口 - JDK8.x提供的,仅仅存在单个抽象方法的接口.

  **@FunctionalInterface**

* 标记接口 - 什么都没有,相当于做了一个记号而已.

  java.io.Serializable - 可序列化接口.

  ~~~java
  public interface ICheckSpeed{//检查速度
    //标记的接口
  }
  public interface IVehicle{
    int getSpeend();
  }
  public class Car implements IVehicle,ICheckSpeed{
      //...
  }
  public class Plane implements IVehicle{
      //...
  }
  
  IVehicle[] vs = new IVehicle[2];
  IVehile car = new Car();
  IVehicle plane = new Plane();
  vs[0] = car;
  vs[1] = plane;
  
  for(IVehicle v:vs){
    if(vs instanceof ICheckSpeed){
      //需要先获取速度
      //判断速度<120
    }else{
      //不需要判断速度.
    }
  }
  ~~~

# 抽象类和接口有什么区别

* 共同点 - 俩者都是属于抽象的数据类型 - 都是不能够被实例化的.
* 不同点



# 回调接口

Callback - you call me , i will call you back.

* 小明去买口罩.

* 小店没货,小明交代老板一旦到货,请联系我.

  小明就留下类自己的***手机号码[回调接口]***

* 货到了[触发回调方法的事件],老板就开始拨打电话
* 接通,小明开始回应,不买!!!

使用回调接口来代替模板设计模式.

~~~java

~~~







